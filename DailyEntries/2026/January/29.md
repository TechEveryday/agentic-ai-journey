# Day1 / Overview
Alright, today marks Day 1 of this journey. Today I am mainly just getting everything setup, and figuring out what "everything" even is.

# Setup

## Gemini
Currently using the free Tier

I've installed Gemini CLI following the instructions here
https://geminicli.com/docs/get-started/installation/#1-standard-installation-recommended-for-standard-users

Which ultimately was just `npm install -g @google/gemini-cli`

How can I use gemini from the cli? Just type in `gemini` into your terminal window to start up your session

Note: it doesn't say, but you should have nodev20 installed.

After installing the CLI, I needed to get an API key, grabbed that from here
https://aistudio.google.com/app/apikey

Then added it to my `~/.zshrc` file
`export GEMINI_API_KEY="YOUR_GEMINI_API_KEY"`

Jotting the headline documentation for later usage

https://geminicli.com/docs/cli/headless/

### Pricing / Plans
To fill out later if ever

## Claude
I am currently using the free tier, supposedly.

To install the cli I ran the following
`brew install --cask claude-code`

And this is when I realized that I was paywalled. Can't use Claude CLI unless you pay for the pro plan.

### Pricing / Plans
Free - $0/mo,       web chat only     limited usage
Pro  - $17/mo,      web chat + cli    > usage than free
Max  - $100-$200/mo web chat + cli    5x/20x usage

## ChatGPT
Also currently using the free tier here.

Generate your API key.
https://platform.openai.com/api-keys

Add that to your `~/.zshrc` file again as an variable for later consumption
`export OPENAI_API_KEY="your_api_key_here"`

Install the cli using
`npm i -g @openai/codex`

Then run `codex` and sign in with your API key. it should auto pull the value

Information/Documentation here https://developers.openai.com/codex/cli/

### Pricing / Plans
To be filled out later...

## Github CoPilot
This is the only one that I am currently paying for. I think. Well i think I'm on the 30d trial of the pro plan.

### Pricing / Plans
Free    -
Pro     - $10/mo
Premium -

## Cursor
Using the free tier

This is the IDE that I plan on using just to get a feel for it.

Cursor can be found here https://cursor.com/dashboard

I connected my Github repositories as well as connected Linear.

### Pricing / Plans

# Next Steps

## Context
I need to generate some instructions that all of these agents will utilize so that they're all on the same page. For starters, I should point out where my requirements are going to be listed (i'm hoping to be able to rely on Linear here)

After I define where the product requirements are defined, I also want to ensure that the following is in context

- The books that I mentioned earlier so that the way these agents code will be easier to read and maintainable
-- clean architecture by robert martin
-- building microservices by sam newman
-- unit testing by vladimir khorikov
-- domain driven design by eric evans
-- head first design patterns by eric freeman & elisabeth robson
- To include test coverage (I should probably insert playwright mcp here)
- To include what frameworks/language that I would like my code to be in
- provide where the documentation exists for those frameworks/languages
-- For example, I want to have a C# backend, since that's what I know. and I want to have a React frontend, since thats the roles that I've been targeting professionally. For components, probably something along the lines of material-ui just to keep things simple.
- provide that these applications will be deployed on fly.io
- that usage of these AIs must stop once the paywall has reached a certain $$ amount so I don't go broke.
- I also want these applications to be containerized using Docker so then I can deploy them seemlessly across whatever provider I go with Aws/Fly/Azure. Will likely go with Fly, but just in case to have that flexibility.

## Running agents in parralel and communicating across each other
I need to figure this part out it looks like theres an output json available as well as a prompt flag to turn on for these. then I should have them able to communication with each other.

High level approach of how these agents will work

- an agent will look at the requirements/ticket, complete 1 task at a time (multiple agents and multiple tasks can be completed in parallel where applicable)
- I have something telling agents to keep picking up tickets so long as there are still tickets to pick up
- I have something pointing out to these agents where there are dependencies that need to happen in a specific completion order
- I have something to tell all of these agents to stop working once there are no tickets left to be worked.
